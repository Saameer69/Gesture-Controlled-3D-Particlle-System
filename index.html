<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Gesture Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: monospace; }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        
        /* UI Layer */
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            color: #0f0; background: rgba(0,0,0,0.8); padding: 15px;
            border: 1px solid #0f0; border-radius: 8px; pointer-events: none;
            max-width: 300px;
        }
        #controls {
            position: absolute; bottom: 10px; left: 10px; z-index: 20;
            display: flex; gap: 10px;
        }
        .control-button {
            padding: 10px 15px; background: #0088ff; color: white; border: none;
            border-radius: 5px; cursor: pointer; font-size: 14px;
            pointer-events: auto; /* Allow interaction */
        }
        .control-button:hover { background: #00b3ff; }

        /* Debug Canvas for drawing the hand skeleton */
        #debug-canvas {
            z-index: 15;
            pointer-events: none;
            width: 100%; height: 100%;
        }

        /* Input video (visible for debugging) */
        #input-video {
            position: absolute; bottom: 10px; right: 10px;
            width: 160px; height: 120px; z-index: 10;
            transform: scaleX(-1); border: 2px solid #555;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="ui">
        <strong>STATUS:</strong> <span id="status-text">Initializing...</span><br>
        <strong>CURRENT SHAPE:</strong> <span id="shape-name">Sphere</span><br>
        --------------------------<br>
        <strong>HAND DETECTED:</strong> <span id="hand-detected" style="color:red">NO</span><br>
        <strong>PINCH DISTANCE:</strong> <span id="pinch-val">0.00</span><br>
        <strong>HAND X:</strong> <span id="hand-x">0.00</span><br>
    </div>

    <div id="controls">
        <button id="prev-shape" class="control-button">Previous Shape</button>
        <button id="next-shape" class="control-button">Next Shape</button>
    </div>

    <canvas id="debug-canvas"></canvas>
    
    <video id="input-video" playsinline></video>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 15000;
        const MORPH_SPEED = 0.02;

        // --- DOM ELEMENTS ---
        const debugCanvas = document.getElementById('debug-canvas');
        const debugCtx = debugCanvas.getContext('2d');
        const uiHand = document.getElementById('hand-detected');
        const uiPinch = document.getElementById('pinch-val');
        const uiX = document.getElementById('hand-x');
        const uiStatus = document.getElementById('status-text');
        const uiShapeName = document.getElementById('shape-name');
        
        // Resize debug canvas
        debugCanvas.width = window.innerWidth;
        debugCanvas.height = window.innerHeight;

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, particles, material;
        let handLandmarks = null;
        let currentShapeIndex = 0;
        const SHAPES = []; // Array to hold all shape coordinate buffers
        const SHAPE_NAMES = []; // Array to hold shape names

        // --- 1. NEW SHAPE GENERATORS ---

        // Heart, Sphere, Flower are from previous version (omitted for brevity)
        function getSpherePoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 4;
                points.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            }
            return points;
        }
        function getHeartPoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = 0.2 + Math.random() * 0.1; 
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 4;
                points.push(x * r, y * r, z);
            }
            return points;
        }
        function getFlowerPoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 3 + Math.sin(5 * u) * Math.sin(5 * v); 
                points.push(r * Math.sin(v) * Math.cos(u), r * Math.sin(v) * Math.sin(u), r * Math.cos(v));
            }
            return points;
        }

        // --- NEW SHAPES ---

        function getSpiralGalaxyPoints(count) {
            const points = [];
            const armCount = 3;
            for (let i = 0; i < count; i++) {
                const r = Math.random() * 6;
                const baseAngle = Math.random() * Math.PI * 2;
                
                // Choose an arm
                const armIndex = Math.floor(Math.random() * armCount);
                
                // Archimedean spiral formula: angle = r * constant
                const spiralAngle = r * 0.8;
                const angle = baseAngle + spiralAngle + (armIndex * Math.PI * 2 / armCount);
                
                points.push(
                    r * Math.cos(angle),
                    (Math.random() - 0.5) * r * 0.1, // Slight Z-thickness
                    r * Math.sin(angle)
                );
            }
            return points;
        }
        
        function getFireworksEmitterPoints(count) {
            // These points don't form a static shape, but a central emitter point, 
            // which the shader will then explode based on velocity attributes.
            // For a successful morph target, we set them all to the center.
            const points = [];
            for (let i = 0; i < count; i++) {
                points.push(
                    (Math.random() - 0.5) * 0.5, // Small central volume
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
            }
            return points;
        }

        async function getLogoPoints(count) {
             // Create points from a pre-defined path (e.g., a simple logo shape)
             // We'll use a simple "S" shape for demonstration
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.lineTo(1, 0);
            shape.lineTo(1, 4);
            shape.lineTo(0, 4);
            shape.lineTo(0, 5);
            shape.lineTo(2, 5);
            shape.lineTo(2, -1);
            shape.lineTo(-1, -1);
            shape.lineTo(-1, 0);
            shape.lineTo(0, 0);
            
            const geometry = new THREE.ShapeGeometry(shape, 10);
            const vertices = geometry.attributes.position.array;
            const points = [];

            // Sample points from the geometry vertices
            // Since PARTICLE_COUNT >> geometry vertices, we resample/duplicate
            for(let i = 0; i < count; i++) {
                const index = Math.floor(Math.random() * (vertices.length / 3)) * 3;
                points.push(
                    vertices[index] * 2, // X
                    vertices[index + 1] * 2, // Y
                    (Math.random() - 0.5) * 1 // Z-thickness
                );
            }
            return points;
        }

        // --- 2. THREE.JS SETUP & MORPHING LOGIC ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Generate ALL Shapes
            SHAPES.push(getSpherePoints(PARTICLE_COUNT)); SHAPE_NAMES.push("Sphere");
            SHAPES.push(getHeartPoints(PARTICLE_COUNT)); SHAPE_NAMES.push("Heart");
            SHAPES.push(getFlowerPoints(PARTICLE_COUNT)); SHAPE_NAMES.push("Flower");
            SHAPES.push(getSpiralGalaxyPoints(PARTICLE_COUNT)); SHAPE_NAMES.push("Galaxy");
            SHAPES.push(getFireworksEmitterPoints(PARTICLE_COUNT)); SHAPE_NAMES.push("Fireworks Emitter");
            getLogoPoints(PARTICLE_COUNT).then(p => {
                SHAPES.push(p); 
                SHAPE_NAMES.push("Logo 'S'");
                // Initialize geometry after async load
                createParticleSystem();
            });

            // Handle Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                debugCanvas.width = window.innerWidth;
                debugCanvas.height = window.innerHeight;
            });
        }
        
        function createParticleSystem() {
            // Wait for all shapes to load before creating geometry
            if (SHAPES.length < 6) return; 

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(SHAPES[0]);
            const targets = new Float32Array(SHAPES[0]); 
            
            // Per-particle attributes for custom effects (e.g., color, velocity)
            const randoms = new Float32Array(PARTICLE_COUNT).map(() => Math.random());
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targets, 3));
            geometry.setAttribute('randomValue', new THREE.BufferAttribute(randoms, 1));


            // --- SHADER MATERIAL ---
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMix: { value: 0 },
                    uExpansion: { value: 0 },
                    uColor: { value: new THREE.Color(0x00ff88) },
                    uShapeType: { value: 0 } // 4: Galaxy, 5: Fireworks Emitter
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uMix;
                    uniform float uExpansion;
                    uniform float uShapeType;
                    attribute vec3 targetPosition;
                    attribute float randomValue;
                    varying vec3 vColor;
                    
                    void main() {
                        vec3 pos = mix(position, targetPosition, uMix);
                        vec3 finalPos = pos;
                        
                        // Hand-Gesture Expansion (applied to all)
                        finalPos += normalize(pos) * uExpansion * 8.0; 
                        
                        // SHAPE-SPECIFIC EFFECTS
                        if (uShapeType == 3.0) { // Galaxy
                            float r = length(pos.xz);
                            float twist = sin(r * 0.5 + uTime * 0.1) * 0.5;
                            finalPos.y += twist;
                            finalPos.z += cos(uTime * 0.5) * 0.01;
                            
                            // Color based on radius (r)
                            vColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.5, 0.0), smoothstep(1.0, 6.0, r));
                        } else if (uShapeType == 4.0) { // Fireworks Emitter
                            // Use randomValue for velocity/lifetime
                            float lifetime = mod(uTime + randomValue * 5.0, 5.0);
                            float age = lifetime / 5.0; // 0 to 1
                            
                            // Explosive movement, re-sets every 5 seconds
                            vec3 velocity = normalize(pos) * randomValue * 4.0;
                            finalPos += velocity * age * 5.0; // Explosion trail
                            
                            // Color transition (Blue to Yellow burst)
                            vColor = mix(vec3(0.1, 0.1, 1.0), vec3(1.0, 0.8, 0.0), age);
                        } else {
                            // Default Color (based on user input or static color)
                            vColor = vec3(0.0, 1.0, 0.5); // Default cyan/green
                        }

                        // Wiggle effect (applied to all non-fireworks)
                        if (uShapeType != 4.0) {
                             finalPos.x += sin(uTime * randomValue * 2.0 + finalPos.y) * 0.1;
                        }
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = 4.0 * (10.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying vec3 vColor;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        float glow = 1.0 - (r * 2.0);
                        gl_FragColor = vec4(vColor, pow(glow, 1.5));
                    }
                `,
                transparent: true, blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateMorphTarget(newIndex) {
            if (newIndex === currentShapeIndex) return;

            // Ensure the target is loaded
            if (newIndex >= SHAPES.length || !SHAPES[newIndex]) {
                 console.error("Shape index out of bounds or not loaded:", newIndex);
                 return;
            }

            const positionAttribute = particles.geometry.attributes.position;
            const targetAttribute = particles.geometry.attributes.targetPosition;
            
            // Set current position buffer to the target buffer,
            // then set the new target
            positionAttribute.array.set(SHAPES[currentShapeIndex]);
            targetAttribute.array.set(SHAPES[newIndex]);
            
            positionAttribute.needsUpdate = true;
            targetAttribute.needsUpdate = true;

            currentShapeIndex = newIndex;
            material.uniforms.uMix.value = 0;
            
            // Update UI and Shader Type Uniform
            uiShapeName.innerText = SHAPE_NAMES[newIndex];
            material.uniforms.uShapeType.value = newIndex; 
        }

        // --- 3. MEDIAPIPE & GESTURE LOGIC (Reused from Debug Version) ---
        function initMediaPipe() {
            // ... (MediaPipe setup code omitted for brevity, identical to previous Debug version)
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            hands.onResults(onResults);
            const cam = new window.Camera(document.getElementById('input-video'), {onFrame: async () => { await hands.send({image: document.getElementById('input-video')}); }, width: 640, height: 480});
            cam.start();
            uiStatus.innerText = "Running";
        }
        
        function onResults(results) {
            debugCtx.save();
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            debugCtx.scale(-1, 1);
            debugCtx.translate(-debugCanvas.width, 0);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks[0];
                for (const landmarks of results.multiHandLandmarks) {
                    window.drawConnectors(debugCtx, landmarks, window.HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
                    window.drawLandmarks(debugCtx, landmarks, {color: '#FF0000', lineWidth: 2});
                }
                uiHand.innerText = "YES";
                uiHand.style.color = "#0f0";
            } else {
                handLandmarks = null;
                uiHand.innerText = "NO";
                uiHand.style.color = "red";
            }
            debugCtx.restore();
        }


        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            if (!particles) {
                // Wait for async load to finish
                renderer.render(scene, camera);
                return;
            }

            material.uniforms.uTime.value = time;
            
            // Smooth morph transition (using lerp towards 1)
            material.uniforms.uMix.value = THREE.MathUtils.lerp(material.uniforms.uMix.value, 1, 0.03);

            // Hand Interactions
            let expansion = 0;
            if (handLandmarks) {
                const thumb = handLandmarks[4];
                const index = handLandmarks[8];
                const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));

                uiPinch.innerText = dist.toFixed(3);
                uiX.innerText = handLandmarks[9].x.toFixed(2);

                expansion = Math.max(0, (dist - 0.05) * 5.0);
                
                const rotTargetY = (handLandmarks[0].x - 0.5) * 5.0;
                const rotTargetX = (handLandmarks[0].y - 0.5) * 5.0;
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, rotTargetY, 0.1);
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, rotTargetX, 0.1);
                
                // Color change based on Y height
                const hue = Math.max(0, Math.min(1, handLandmarks[0].y * 1.5));
                material.uniforms.uColor.value.setHSL(hue, 1.0, 0.5);

            } else {
                particles.rotation.y += 0.002; // Idle spin
            }

            material.uniforms.uExpansion.value = THREE.MathUtils.lerp(material.uniforms.uExpansion.value, expansion, 0.1);

            renderer.render(scene, camera);
        }

        // --- 5. CONTROLS ---
        document.getElementById('next-shape').addEventListener('click', () => {
            const next = (currentShapeIndex + 1) % SHAPES.length;
            updateMorphTarget(next);
        });

        document.getElementById('prev-shape').addEventListener('click', () => {
            let prev = currentShapeIndex - 1;
            if (prev < 0) prev = SHAPES.length - 1;
            updateMorphTarget(prev);
        });
        
        // --- INITIALIZATION ---
        initThree();
        initMediaPipe();
        animate();
    </script>
</body>
</html>